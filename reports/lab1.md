# Lab 1 报告

## 实现功能

在`TaskControlBlock`中增加`syscall_times`和`starting_time`两个信息进行维护, 分别代表系统调用次数和任务第一次被调度的时刻, `syscall_times`在进入内核态系统调用异常处理函数之后, 进入具体系统调用函数函数之前的`syscall`中进行维护, `starting_time`在任务管理器第一次调度某一任务时记录当时的时刻, `TaskInfo`中由于查询的是当前正在运行的任务, `status`一定是`running`, 调用任务管理器实现的查询的函数即可获得`syscall_times`, `starting_time`可以与查询任务状态的时刻做差得到.

## 问答题

1. 
- 处于 U 态访问`0x0`地址, `0x0`地址不能被 U 态的应用程序访问.
- `sret`指令用于内核态切换回用户态, 跳转到`sepc`寄存器所指向的内存地址开始执行, 属于高特权级指令, 不能由用户态调用该指令.
- `sstatus`寄存器保存了`Trap`发生之前的信息, S 特权级才能访问, 用户态不能访问.

2. 
  1. `a0`指向内核栈栈顶, `__restore`用于处理`Trap`后恢复用户态的上下文和启动应用程序时构造应用程序的上下文.
  2. 处理了`sstatus`, `sepc`, `sscratch`三个寄存器, `sstatus`存储`Trap`之前 CPU 处于哪个特权级等信息, `sepc`指向`Trap`发生之前最后一天指令的地址, `sscratch`指向用户栈顶地址. 
  3. `x2`指向内核栈, `x4`寄存器除了手动处于一些特殊用途使用, 一般不会使用.
  4. 交换两者的内容, 使`sp`指向内核栈, `sscratch`指向用户栈.
  5. `sret`指令发生状态切换, 从`sstatus`和`sepc`等寄存器中读取相关的值, 恢复进入`Trap`之前的状态.
  6. 交换两者的内容, 使`sp`指向用户栈, `sscratch`指向内核栈.
  7. `ecall`指令.

## 荣誉准则

1. 在完成本次实验的过程（含此前学习的过程）中，我曾分别与 以下各位 就（与本次实验相关的）以下方面做过交流，还在代码中对应的位置以注释形式记录了具体的交流对象及内容：
   
2. 此外，我也参考了 以下资料 ，还在代码中对应的位置以注释形式记录了具体的参考来源及内容：
   
3. 我独立完成了本次实验除以上方面之外的所有工作，包括代码与文档。 我清楚地知道，从以上方面获得的信息在一定程度上降低了实验难度，可能会影响起评分。
   
4. 我从未使用过他人的代码，不管是原封不动地复制，还是经过了某些等价转换。 我未曾也不会向他人（含此后各届同学）复制或公开我的实验代码，我有义务妥善保管好它们。 我提交至本实验的评测系统的代码，均无意于破坏或妨碍任何计算机系统的正常运转。 我清楚地知道，以上情况均为本课程纪律所禁止，若违反，对应的实验成绩将按“-100”分计。